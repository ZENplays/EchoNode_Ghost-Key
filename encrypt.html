<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ghost-Key v3.5.5 - EchoNode CLI</title>
    <style>
        h2, label, strong, button { -webkit-user-select: none; user-select: none; }
        body { font-family: 'Courier New', monospace; background: #08080c; color: #00d4ff; padding: 20px; line-height: 1.2; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .box { border: 1px solid #00d4ff; padding: 15px; background: #111118; box-shadow: 0 0 10px #00d4ff22; display: flex; flex-direction: column; }
        textarea { width: 100%; height: 300px; background: #000; color: #00ff88; border: 1px solid #222; padding: 10px; box-sizing: border-box; font-size: 0.8rem; flex-grow: 1; outline: none; border: 1px solid #222; }
        .controls { display: flex; flex-direction: column; gap: 8px; margin-top: 10px; }
        
        /* Primary Buttons (Solid) */
        button { background: #00d4ff; color: #000; border: none; padding: 12px; cursor: pointer; font-weight: bold; text-transform: uppercase; }
        button:hover { background: #fff; color: #000; }
        
        /* Secondary Buttons (Outlined/Black Inside) */
        .btn-outline-blue { background: #000; color: #00d4ff; border: 1px solid #00d4ff; font-size: 0.75rem; padding: 8px; }
        .btn-outline-blue:hover { background: #00d4ff; color: #000; }
        
        .btn-outline-green { background: #000; color: #00ff88; border: 1px solid #00ff88; font-size: 0.75rem; padding: 8px; }
        .btn-outline-green:hover { background: #00ff88; color: #000; }

        #transcript { margin-top: 20px; height: 120px; overflow-y: auto; border: 1px solid #333; background: #000; padding: 15px; font-size: 0.85rem; color: #00ff88; }
        .log-entry { margin-bottom: 8px; border-left: 3px solid #00d4ff; padding-left: 10px; word-break: break-all; }
        .fallback-link { color: #ff00ff; text-decoration: underline; cursor: pointer; font-size: 0.7rem; }
    </style>
</head>
<body>

    <div class="box" style="margin-bottom: 20px; border-color: #333;">
        <label>CORE_SIGNATURE: </label>
        <input type="text" id="anchorKey" value="!#BSOD#!" style="background:#000; color:#00d4ff; border:1px solid #333; padding:2px; font-family:inherit;">
    </div>

    <div class="grid">
        <div class="box">
            <h2>Outbound: EchoNode Encoder</h2>
            <textarea id="plainInput" placeholder="Enter telemetry data..."></textarea>
            <div class="controls">
                <button onclick="runGhostEncrypt(false)">Generate Encrypted Message</button>
                <button class="btn-outline-blue" onclick="runGhostEncrypt(true)">Export .log file</button>
            </div>
        </div>

        <div class="box" style="border-color: #00ff88;">
            <h2 style="color: #00ff88;">Inbound: Analyze Debug Data</h2>
            <textarea id="cipherOutput" placeholder="Paste log content..."></textarea>
            <div class="controls">
                <button style="background:#00ff88;" onclick="runGhostDecrypt()">Decode Memory Stream</button>
                <input type="file" id="fileInput" style="display:none;" onchange="importFromFile(this)">
                <button class="btn-outline-green" onclick="document.getElementById('fileInput').click()">Import .log file</button>
            </div>
        </div>
    </div>

    <div id="transcript">
        <div class="log-entry">EchoNode Subsystem [v3.5.5] Online. Randomization Depth: Active.</div>
    </div>

<script>
// Logic remains unchanged per your instructions
const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.,!?@#$%^&*()-_=+[]{} ";
const morseMap = {'1':'.----','2':'..---','3':'...--','4':'....-','5':'.....','6':'-....','7':'--...','8':'---..','9':'----.','0':'-----','/':'-..-.'};
const revMorse = Object.fromEntries(Object.entries(morseMap).map(([k,v])=>[v,k]));
const noisePool = "0123456789ABCDEFHIJKLMNOPQRSTUVWXYZ!@#$%^&*";
const TERMINATOR = "%1O0X!";

function addLog(sender, text, isHtml = false) {
    const log = document.getElementById('transcript');
    const entry = document.createElement('div');
    entry.className = 'log-entry';
    const strong = document.createElement('strong');
    strong.textContent = sender.toUpperCase() + ": ";
    entry.appendChild(strong);
    if(isHtml) { entry.innerHTML += text; } 
    else { entry.appendChild(document.createTextNode(text)); }
    log.appendChild(entry);
    log.scrollTop = log.scrollHeight;
}

function runGhostEncrypt(autoExport = false) {
    let input = document.getElementById('plainInput').value.toUpperCase();
    if(!input) return;
    let anchor = document.getElementById('anchorKey').value;
    addLog('user', input);

    let leadInNoise = "";
    let leadInCount = Math.floor(Math.random() * 200) + 50; 
    for(let i=0; i<leadInCount; i++) {
        leadInNoise += noisePool[Math.floor(Math.random() * noisePool.length)];
    }

    let secretKey = "";
    for(let i=0; i<10; i++) secretKey += (Math.floor(Math.random() * 4) + 1);

    let rawMorseData = "";
    for (let char of input) {
        let index = charset.indexOf(char);
        if (index === -1) continue;
        let coords = (Math.floor(index / 8) + 1).toString() + ((index % 8) + 1).toString() + "/";
        for (let c of coords) { rawMorseData += morseMap[c]; }
    }

    let body = "";
    let keyIdx = 0;
    for (let bit of rawMorseData) {
        let junkCount = parseInt(secretKey[keyIdx % secretKey.length]);
        for (let i = 0; i < junkCount; i++) {
            body += noisePool[Math.floor(Math.random() * noisePool.length)];
        }
        if (bit === ".") body += Math.floor(Math.random() * 10);
        else body += noisePool[10 + Math.floor(Math.random() * (noisePool.length - 10))];
        keyIdx++;
    }

    body += TERMINATOR;
    let autoJunk = Math.floor(Math.random() * 800);
    for(let i=0; i < autoJunk; i++) {
        body += noisePool[Math.floor(Math.random() * noisePool.length)];
    }

    const audioProcs = ["Oscillator.vst3", "ReverbUnit.dll", "EchoNode_Core.exe", "FilterBank.sys"];
    let randProc = audioProcs[Math.floor(Math.random()*audioProcs.length)];
    
    let fullPayload = leadInNoise + anchor + secretKey + body;
    let formattedPayload = fullPayload.match(/.{1,55}/g).join('\n');

    let crashReport = `--- ECHO-NODE CRITICAL DUMP ---\nMODULE: ${randProc} | TS: ${new Date().toISOString()}\n`;
    crashReport += `------------------------------------------------------\n`;
    crashReport += `${formattedPayload}\n`;
    crashReport += `------------------------------------------------------\n`;
    crashReport += `STREAMS_CAPTURED: 1 | STATUS: DUMP_COMPLETE`;

    document.getElementById('cipherOutput').value = crashReport;
    document.getElementById('plainInput').value = "";
    
    if(autoExport) {
        executeDownload(crashReport);
    } else {
        addLog('system', `Encoded message (Preview generated).`);
    }
}

function executeDownload(text) {
    const filename = `debug_log_${Math.floor(Date.now()/1000)}.log`;
    try {
        const element = document.createElement('a');
        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
        element.setAttribute('download', filename);
        element.style.display = 'none';
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
        addLog('system', `Direct Export Successful.`);
    } catch (e) {
        const fallback = `<br><a class="fallback-link" href="data:text/plain;charset=utf-8,${encodeURIComponent(text)}" download="${filename}">[!] CLICK TO MANUALLY SAVE</a>`;
        addLog('system', `Export Blocked. ${fallback}`, true);
    }
}

function runGhostDecrypt() {
    let wall = document.getElementById('cipherOutput').value;
    let anchor = document.getElementById('anchorKey').value;
    let cleanWall = wall.replace(/\s/g, '');
    let anchorPos = cleanWall.indexOf(anchor);
    if (anchorPos === -1) { addLog('system', 'ERROR: ANCHOR NOT FOUND.'); return; }

    let key = cleanWall.substring(anchorPos + anchor.length, anchorPos + anchor.length + 10);
    let body = cleanWall.substring(anchorPos + anchor.length + 10);
    if(body.indexOf(TERMINATOR) !== -1) body = body.substring(0, body.indexOf(TERMINATOR));

    let extractedMorse = "";
    let keyIdx = 0, cursor = 0;
    while (cursor < body.length) {
        cursor += parseInt(key[keyIdx % key.length]);
        if (cursor >= body.length) break;
        let char = body[cursor];
        extractedMorse += (char >= '0' && char <= '9') ? "." : "-";
        cursor++; keyIdx++;
    }

    let coords = "";
    for (let i = 0; i < extractedMorse.length; i += 5) {
        let chunk = extractedMorse.substring(i, i + 5);
        coords += revMorse[chunk] || "";
    }

    let finalMsg = "";
    let coordPairs = coords.split("/");
    coordPairs.forEach(pair => {
        if (pair.length < 2) return;
        let r = parseInt(pair[0]) - 1, c = parseInt(pair[1]) - 1;
        finalMsg += charset[(r * 8) + c] || "";
    });

    if(finalMsg) {
        addLog('remote', finalMsg);
        document.getElementById('plainInput').value = finalMsg;
    } else { addLog('system', 'RECONSTRUCTION FAILED.'); }
}

function importFromFile(input) {
    let file = input.files[0];
    if (!file) return;
    let reader = new FileReader();
    reader.onload = function() {
        document.getElementById('cipherOutput').value = reader.result;
        addLog('system', `Imported ${file.name}`);
        runGhostDecrypt();
    };
    reader.readAsText(file);
}
</script>
</body>
</html>
